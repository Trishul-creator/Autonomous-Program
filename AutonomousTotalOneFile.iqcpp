{"mode":"Text","hardwareTarget":"brain","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\ninertial BrainInertial = inertial();\nmotor LeftDriveSmart = motor(PORT4, 1, false);\nmotor RightDriveSmart = motor(PORT3, 1, true);\n\nsmartdrive Drivetrain = smartdrive(LeftDriveSmart, RightDriveSmart, BrainInertial, 200);\n\nmotor LauncherMotorA = motor(PORT1, false);\nmotor LauncherMotorB = motor(PORT6, true);\nmotor_group Launcher = motor_group(LauncherMotorA, LauncherMotorB);\n\nmotor IntakeMotor = motor(PORT2, true);\nmotor BackRoller = motor(PORT5, true);\n\n\n// generating and setting random seed\nvoid initializeRandomSeed(){\n  wait(100,msec);\n  double xAxis = BrainInertial.acceleration(xaxis) * 1000;\n  double yAxis = BrainInertial.acceleration(yaxis) * 1000;\n  double zAxis = BrainInertial.acceleration(zaxis) * 1000;\n  // Combine these values into a single integer\n  int seed = int(\n    xAxis + yAxis + zAxis\n  );\n  // Set the seed\n  srand(seed); \n}\n\nbool vexcode_initial_drivetrain_calibration_completed = false;\nvoid calibrateDrivetrain() {\n  wait(200, msec);\n  Brain.Screen.print(\"Calibrating\");\n  Brain.Screen.newLine();\n  Brain.Screen.print(\"Inertial\");\n  BrainInertial.calibrate();\n  while (BrainInertial.isCalibrating()) {\n    wait(25, msec);\n  }\n  vexcode_initial_drivetrain_calibration_completed = true;\n  // Clears the screen and returns the cursor to row 1, column 1.\n  Brain.Screen.clearScreen();\n  Brain.Screen.setCursor(1, 1);\n}\n\nvoid vexcodeInit() {\n\n  // Calibrate the Drivetrain\n  calibrateDrivetrain();\n\n  // Initializing random seed.\n  initializeRandomSeed(); \n}\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       {author}                                                  \n//    Created:      {date}                                                    \n//    Description:  IQ project                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\n\nclass PIDController {\n    public:\n        PIDController(double kP, double kI, double kD, double turnkP, double turnkI, double turnkD);\n        void setDesiredValue(int value);\n        void setTurnDesiredValue(int value);\n        int calculate(int currentPosition);\n        int calculateTurn(int currentAngle);\n        bool atTarget();\n        bool atTurnTarget();\n\n    private:\n        double kP; // Proportional constant\n        double kI; // Integral constant\n        double kD; // Derivative constant\n\n        double turnkP; // Turn Propotional constant\n        double turnkI; // Turn Integral constant\n        double turnkD; // Turn Derivative constant\n\n        int integralBound; // max integral value\n        int maxIntegral; // max integral value\n\n        double desiredValue; // how far it should go\n        double turnDesiredValue; // how far it should turn\n        double error; // Error = desiredValue - currentPosition (Proportional Term of PID)\n        double turnError; // Error = desiredValue - currentPosition (Proportional Term of PID)\n        double prevError; // Error from the last time calculate was called\n        double turnPrevError; // Error from the last time calculate was called\n        double totalError; // integral of error (Integral Term of PID)\n        double totalTurnError; // integral of error (Integral Term of PID)\n        double derivative; // derivative of error (Derivative Term of PID) error - prevError\n        double turnDerivative; // derivative of error (Derivative Term of PID) error - prevError\n\n        \n};\n\nPIDController::PIDController(double kP, double kI, double kD, double turnkP, double turnkI, double turnkD) {\n    this->kP = kP;\n    this->kI = kI;\n    this->kD = kD;\n\n    this->turnkP = turnkP;\n    this->turnkI = turnkI;\n    this->turnkD = turnkD;\n\n    this->integralBound = 3;\n    this->maxIntegral = 300;\n\n    this->desiredValue = 0;\n    this->turnDesiredValue = 0;\n    this->error = 0;\n    this->turnError = 0;\n    this->prevError = 0;\n    this->turnPrevError = 0;\n    this->totalError = 0;\n    this->totalTurnError = 0;\n    this->derivative = 0;\n    this->turnDerivative = 0;\n}\n\nvoid PIDController::setDesiredValue(int value) {\n    this->desiredValue = value;\n}\n\nvoid PIDController::setTurnDesiredValue(int value) {\n    this->turnDesiredValue = value;\n}\n\n\n\nint PIDController::calculate(int currentPosition) {\n    this->error = this->desiredValue - currentPosition;\n    this->derivative = this->error - this->prevError;\n    \n    if (abs(this->error) > this->integralBound) {\n        this->totalError += this->error;\n    } else {\n        totalError = 0;\n    }\n\n    int output = (this->kP * this->error) + (this->kI * this->totalError) + (this->kD * this->derivative);\n\n    if(output > 100) {\n      output = 100;\n    } else if(output < 0) {\n      output = 0; \n    }\n    this->prevError = this->error;\n    return output;\n    \n}\n\nint PIDController::calculateTurn(int currentAngle) {\n    this->turnError = this->turnDesiredValue - currentAngle;\n    this->turnDerivative = this->turnError - this->turnPrevError;\n    \n    if (abs(this->turnError) > this->integralBound) {\n        this->totalTurnError += this->turnError;\n    } else {\n        totalTurnError = 0;\n    }\n\n    int output = (this->turnkP * this->turnError) + (this->turnkI * this->totalTurnError) + (this->turnkD * this->turnDerivative);\n\n    if(output > 100) {\n      output = 100;\n    } else if(output < 0) {\n      output = 0; \n    }\n    this->turnPrevError = this->turnError;\n    return output;\n    \n}\n\nbool PIDController::atTarget() {\n    return (abs(this->error) < 0.5 && abs(this->error) > -0.5);\n}\n\nbool PIDController::atTurnTarget() {\n    return (abs(this->turnError) < 0.5 && abs(this->turnError) > -0.5);\n}\n\nvoid drive(PIDController& pid, int distance, vex::directionType direction) {\n  pid.setDesiredValue(distance);\n\n  while (!pid.atTarget()) {\n    int leftMotorPosition = LeftDriveSmart.position(degrees) * 200 * M_PI / 360;\n    int rightMotorPosition = RightDriveSmart.position(degrees) * 200 * M_PI / 360;\n    int averagePosition = (leftMotorPosition + rightMotorPosition) / 2;\n\n    int motorPower = pid.calculate(averagePosition);\n\n    \n\n    LeftDriveSmart.spin(direction, motorPower, percent);\n    RightDriveSmart.spin(direction, motorPower, percent);\n    wait(20, msec);\n  }\n  Drivetrain.stop();\n}\n\nvoid turn(PIDController& pid, int angle, vex::turnType rightOrLeft) {\n  pid.setTurnDesiredValue(angle);\n\n  while (!pid.atTurnTarget()) {\n    int currentAngle = BrainInertial.rotation();\n    int turnPower = pid.calculateTurn(currentAngle);\n\n    if(rightOrLeft == right) {\n      LeftDriveSmart.spin(forward, turnPower, percent);\n      RightDriveSmart.spin(reverse, turnPower, percent);\n    } else if(rightOrLeft == left){\n      LeftDriveSmart.spin(reverse, turnPower, percent);\n      RightDriveSmart.spin(forward, turnPower, percent);\n    } else {\n      Brain.Screen.print(\"Invalid turn type\");\n    }\n    wait(20, msec);\n  }\n  Drivetrain.stop();\n}\n\nvoid shootTopGoal() {\n    Launcher.spinFor(forward, 40, degrees);\n}\n\nvoid setPositionForShooting() {\n    Launcher.spinFor(reverse, 615, degrees, false);\n}\n\nvoid backRollerLauncherPosition() {\n    Launcher.spinFor(forward, 430, degrees, false);\n}\n\nvoid backRollerLauncherPositionRelease() {\n    Launcher.spinFor(reverse, 20, degrees);\n}\n\n\nPIDController pid = PIDController(0.5,0.0,0.0, 0.5, 0.0, 0.0);\nint points = 0;\nint goalNumber = 0;\nint oneSwitchPoint = 0;\nint oneSwitchIncrement = 0;\n\nvoid pointCalculator(bool switchIncrementDesicision) { // switchIncrementDesicion, if switch cleared or not\n    Brain.playSound(tada); // Play sound for getting goal\n    if(switchIncrementDesicision == true) {\n        oneSwitchIncrement += 4; // Increment the point value for each switch cleared\n        printf(\"1 switch cleared !\"); // Print to the console that a switch was cleared\n        printf(\"Every goal is worth %d points\", oneSwitchIncrement); // Print to the console the new point value\n    }\n        goalNumber += 1; // Increment the goal number\n        points = (goalNumber*oneSwitchIncrement)+(oneSwitchPoint*(oneSwitchIncrement/4)); // Calculate the total points\n        printf(\"%dst Goal Shot !\", goalNumber); // Print to the console the goal number\n        printf(\"The score is %d\", points); // Print to the conosole the total points\n}\n\nvoid preAuton() {\n    // Set velocity and turn parameters\n    Launcher.setVelocity(100, percent); // Set the velocity of the launcher to 100 percent\n    printf(\"Launcher velocity set to 100 percent\"); // Print to the console the velocity of the launcher\n    IntakeMotor.setVelocity(100, percent); // Set the velocity of the intake motor to 100 percent\n    printf(\"Intake velocity set to 100 percent\"); // Print to the console the velocity of the intake motor\n    BackRoller.setVelocity(100, percent); // Set the velocity of the back roller to 100 percent\n    printf(\"Back roller velocity set to 100 percent\"); // Print to the console the velocity of the back roller\n    setPositionForShooting();\n}\n\n// Shoot the goal forward\nvoid initialShoot() {\n    \n    Drivetrain.setHeading(0, degrees); // Set the heading of the drivetrain to 0 degrees\n    drive(pid, 400, reverse); // Drive the robot forward 400 degrees (with PID) toward the ball\n    IntakeMotor.spinFor(forward, 2.5, turns); // Spin the intake motor forward for 2.5 turns to collect ball\n    turn(pid, 180, right); // Turn the robot 180 degrees to the right (with PID) with both balls\n    drive(pid, 550, forward); // Drive the robot forward 550 degrees (with PID) with both balls\n    BackRoller.spinFor(forward, 0.3, turns); // Spin the back roller forward for 0.3 turns to shoot the preloaded ball into bottom goal\n    pointCalculator(true); // Increment the goal number and calculate the total points\n    shootTopGoal(); // Shoot the top goal\n    pointCalculator(true); // Increment the goal number and calculate the total points\n\n}\n\nvoid shootOtherSide() {\n    // Shoot other side goals\n    setPositionForShooting(); // Set the position for shooting\n    turn(pid, 30, right); \n    drive(pid, 1097, reverse);\n    IntakeMotor.spinFor(forward, 2.5, turns);\n    turn(pid, 30, left);\n    drive(pid, 950, forward);\n    shootTopGoal();\n    pointCalculator(true);\n    IntakeMotor.spinFor(forward, 2.5, turns, false);\n    BackRoller.spinFor(forward, 2.5, turns);\n    pointCalculator(true);\n}\n\nvoid shootLoop(int numOfShots) {\n    // Shoot Loop\n    for(int i = 0; i < numOfShots; i++) {\n        backRollerLauncherPosition();\n        drive(pid, 920, reverse);\n        IntakeMotor.spinFor(forward, 2.5, turns);\n        drive(pid, 950, forward);\n        shootTopGoal();\n        pointCalculator(true);\n        IntakeMotor.spinFor(forward, 2.5, turns, false);\n        BackRoller.spinFor(forward, 2.5, turns);\n        pointCalculator(true);\n        wait(100, msec);\n    }\n}\n\nvoid autonomousActions() {\n  //queue all autonomous actions here\n  preAuton();\n  initialShoot();\n  shootOtherSide();\n  shootLoop(10);\n}\n\nvoid autonomous() {\n  // Call preAuton and Autonomous Actions\n  preAuton();\n  Brain.buttonUp.pressed(autonomousActions);\n  Brain.Screen.print(\"Autonomous Started\");\n}\n\nvoid autonomousTimer() {\n  // Timer for autonomous\n  int time = 60;\n\n  while(time != 0) {\n    wait(1, seconds);\n    time--;\n    if(time == 10 || time == 20 || time == 30 || time == 40 || time == 50) {\n      printf(\"The time left is %d\",time);\n    }\n  }\n  printf(\"Autonomous Ended\");\n  Brain.playSound(powerDown);\n  Brain.Screen.print(\"Autonomous Ended\");\n  Brain.programStop();\n}\n\nint main() {\n  // Initializing Robot Configuration. DO NOT REMOVE!\n  vexcodeInit();\n  // Begin project code\n  //create PIDController instance with desired parameters\n  bool test = true;\n\n  if(test == true) {\n    drive(pid, 1000, forward);\n    turn(pid, 90, right);\n  } else {\n    thread timerThread = thread(autonomousTimer);\n    thread autonomousThread = thread(autonomous);\n    timerThread.detach();\n    autonomousThread.detach();\n  }\n  \n} ","textLanguage":"cpp","robotConfig":[{"port":[4,3,0],"name":"Drivetrain","customName":false,"deviceType":"Drivetrain","deviceClass":"smartdrive","setting":{"type":"2-motor","wheelSize":"200mm","gearRatio":"1:1","direction":"fwd","gyroType":"integrated","width":"173","unit":"mm","wheelbase":"76","wheelbaseUnit":"mm","xOffset":"0","yOffset":"0","thetaOffset":"0"},"triportSourcePort":22},{"port":[1,6],"name":"Launcher","customName":true,"deviceType":"MotorGroup","deviceClass":"motor_group","setting":{"fwd":"forward","rev":"reverse","motor_a_reversed":"false","motor_b_reversed":"true"}},{"port":[2],"name":"IntakeMotor","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"}},{"port":[5],"name":"BackRoller","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse"}}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.0.7","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false}